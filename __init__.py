# SPDX-License-Identifier: GPL-2.0-or-later
import bpy
from math import pi
from mathutils import Euler
import os
from fnmatch import translate
from bl_operators.presets import AddPresetBase

bl_info = {
    "name": "Bone Animation Copy",
    "author": "Kumopult <kumopult@qq.com>, maylog",
    "description": "Copy animation between different armatures using bone constraints",
    "blender": (4, 2, 0),
    "version": (1, 0, 2),
    "location": "View 3D > Toolshelf",
    "category": "Animation",
    "doc_url": "https://github.com/mayloglog/blender_BoneAnimCopy",
    "tracker_url": "https://space.bilibili.com/1628026",
}

# =============================================
# Utility Functions
# =============================================

def get_state():
    """Get the BAC state from the scene."""
    return bpy.context.scene.kumopult_bac_owner.data.kumopult_bac if bpy.context.scene.kumopult_bac_owner else None

def alert_error(title: str, message: str):
    """Display an error popup."""
    def draw(self, context):
        self.layout.label(text=message)
    bpy.context.window_manager.popup_menu(draw, title=title, icon='ERROR')

# =============================================
# Property Groups
# =============================================

class BAC_BoneMapping(bpy.types.PropertyGroup):
    """Property group for managing a single bone mapping between source and target armatures."""
    
    _constraint_cache = {}  # Cache for constraints

    def _get_constraint(self, con_type: str, name: str, settings: dict = None) -> bpy.types.Constraint:
        """Get or create a constraint with specified type and name."""
        owner_bone = self.get_owner()
        if not owner_bone:
            return None
        con = owner_bone.constraints
        cached = self._constraint_cache.get(name, con.get(name))
        if cached:
            self._constraint_cache[name] = cached
            return cached
        new_con = con.new(type=con_type)
        new_con.name = name
        new_con.show_expanded = False
        if settings:
            for key, value in settings.items():
                setattr(new_con, key, value)
        self._constraint_cache[name] = new_con
        return new_con

    def update_owner(self, context):
        """Update the owner bone and apply constraints."""
        state = get_state()
        if not state:
            return
        self.clear()
        self.owner = self.selected_owner
        owner_bone = self.get_owner()
        if owner_bone and any(not c.name.startswith('BAC') for c in owner_bone.constraints):
            alert_error("Selected bone has other constraints", 
                        "Constraints generated by this add-on (starting with BAC) may cause baking issues if mixed with other constraints. Avoid mapping this bone.")
        if self.is_valid():
            self.apply()

    def update_target(self, context):
        """Update the target bone and calculate rotation offset if enabled."""
        state = get_state()
        if not state or not self.is_valid():
            return
        if state.calc_offset:
            owner_bone, target_bone = self.get_owner(), self.get_target()
            if owner_bone and target_bone:
                euler_offset = ((state.target.matrix_world @ target_bone.matrix).inverted() @ 
                              (state.owner.matrix_world @ owner_bone.matrix)).to_euler()
                if state.ortho_offset:
                    step = pi * 0.5
                    euler_offset = [round(x / step) * step for x in euler_offset]
                if any(euler_offset):
                    self.offset = euler_offset
                    self.has_rotoffs = True
        self.apply()

    def update_rotcopy(self, context):
        """Update the copy rotation constraint."""
        state = get_state()
        if not state or not self.is_valid():
            return
        cr = self.get_cr()
        cr.target, cr.subtarget = state.target, self.target
        cr.enabled = state.preview

    def update_rotoffs(self, context):
        """Update the rotation offset constraint."""
        state = get_state()
        if not state or not self.is_valid():
            return
        rr = self.get_rr()
        if self.has_rotoffs:
            rr.to_min_x_rot, rr.to_min_y_rot, rr.to_min_z_rot = self.offset
            rr.target = rr.space_object = state.target
            rr.subtarget = rr.space_subtarget = self.target
            rr.enabled = state.preview
        else:
            self.remove(rr)

    def update_loccopy(self, context):
        """Update the copy location constraint."""
        state = get_state()
        if not state or not self.is_valid():
            return
        cp = self.get_cp()
        if self.has_loccopy:
            cp.use_x, cp.use_y, cp.use_z = self.loc_axis
            cp.target, cp.subtarget = state.target, self.target
            cp.enabled = state.preview
        else:
            self.remove(cp)

    def update_ik(self, context):
        """Update the IK constraint."""
        state = get_state()
        if not state or not self.is_valid():
            return
        ik = self.get_ik()
        if self.has_ik:
            ik.influence = self.ik_influence
            ik.target, ik.subtarget = state.target, self.target
            ik.enabled = state.preview
        else:
            self.remove(ik)

    def update_selected(self, context):
        """Update the selected count."""
        state = get_state()
        if state and self.is_valid():
            state.selected_count += 1 if self.selected else -1

    selected_owner: bpy.props.StringProperty(
        name="Owner Bone",
        description="Which bone of the owner armature to copy the rotation to?",
        update=update_owner
    )
    owner: bpy.props.StringProperty()
    target: bpy.props.StringProperty(
        name="Target Bone",
        description="Which bone of the target armature to use as the constraint target?",
        update=update_target
    )

    has_rotoffs: bpy.props.BoolProperty(
        name="Rotation Offset",
        description="Add an additional constraint to apply extra rotation to the original transformation result",
        update=update_rotoffs
    )
    has_loccopy: bpy.props.BoolProperty(
        name="Location Mapping",
        description="Add an additional constraint to make the target bone follow the world coordinates of the original bone, typically used for root bones, weapons, etc.",
        update=update_loccopy
    )
    has_ik: bpy.props.BoolProperty(
        name="IK",
        description="Add an additional constraint to make the target bone follow the original bone with IK correction, typically used for hands, feet, etc.",
        update=update_ik
    )

    offset: bpy.props.FloatVectorProperty(
        name="Rotation Offset Amount",
        description="Additional rotation offset applied in world coordinates after copying rotation. Usually only Y rotation needs adjustment",
        min=-pi,
        max=pi,
        subtype='EULER',
        update=update_rotoffs
    )
    loc_axis: bpy.props.BoolVectorProperty(
        name="Location Mapping Axes",
        default=(True, True, True),
        update=update_loccopy
    )
    ik_influence: bpy.props.FloatProperty(
        name="IK Influence Weight",
        default=1,
        min=0,
        max=1,
        update=update_ik
    )

    selected: bpy.props.BoolProperty(update=update_selected)

    def get_owner(self):
        """Get the owner pose bone."""
        state = get_state()
        return state.get_owner_pose().bones.get(self.owner) if state and state.get_owner_pose() else None

    def get_target(self):
        """Get the target pose bone."""
        state = get_state()
        return state.get_target_pose().bones.get(self.target) if state and state.get_target_pose() else None

    def is_valid(self):
        """Check if the mapping is valid."""
        return bool(self.get_owner() and self.get_target())

    def apply(self):
        """Apply all constraints for the mapping."""
        if not self.is_valid():
            return
        self.update_rotcopy(bpy.context)
        self.update_rotoffs(bpy.context)
        self.update_loccopy(bpy.context)
        self.update_ik(bpy.context)

    def clear(self):
        """Clear all constraints for the mapping."""
        owner_bone = self.get_owner()
        if owner_bone:
            for name in ('BAC_ROT_COPY', 'BAC_ROT_ROLL', 'BAC_LOC_COPY', 'BAC_IK'):
                self.remove(self._constraint_cache.get(name))
            self._constraint_cache.clear()

    def remove(self, constraint):
        """Remove a specific constraint."""
        if constraint and (owner_bone := self.get_owner()) and constraint in owner_bone.constraints:
            owner_bone.constraints.remove(constraint)

    def get_cr(self) -> bpy.types.Constraint:
        """Get or create the copy rotation constraint."""
        return self._get_constraint('COPY_ROTATION', 'BAC_ROT_COPY')

    def get_rr(self) -> bpy.types.Constraint:
        """Get or create the rotation roll constraint."""
        return self._get_constraint('TRANSFORM', 'BAC_ROT_ROLL', {'map_to': 'ROTATION', 'owner_space': 'CUSTOM'})

    def get_cp(self) -> bpy.types.Constraint:
        """Get or create the copy location constraint."""
        return self._get_constraint('COPY_LOCATION', 'BAC_LOC_COPY')

    def get_ik(self) -> bpy.types.Constraint:
        """Get or create the IK constraint."""
        return self._get_constraint('IK', 'BAC_IK', {'chain_count': 2, 'use_tail': False})

class BAC_State(bpy.types.PropertyGroup):
    """Manages the state of bone animation copying."""

    _needs_constraint_update = False
    _mapping_cache = {}  # Cache for mapping lookups

    def update_target(self, context):
        """Update the target armature and apply mappings."""
        state = get_state()
        if not state:
            return
        state.owner = bpy.context.scene.kumopult_bac_owner
        state.target = self.selected_target
        if state.target and state.owner:
            state._needs_constraint_update = True
            state._apply_mappings(context)

    def update_preview(self, context):
        """Update constraints for animation preview."""
        state = get_state()
        if not state:
            return
        if state.preview:
            state._needs_constraint_update = True
            state._apply_mappings(context)
        else:
            state._clear_mappings_cache()

    def update_active(self, context):
        """Synchronize active bone selection."""
        state = get_state()
        if not state or not state.sync_select or state.active_mapping < 0:
            return
        mapping = state.mappings[state.active_mapping]
        owner_arm, target_arm = state.get_owner_armature(), state.get_target_armature()
        if owner_arm and (owner_active := owner_arm.bones.get(mapping.owner)):
            owner_arm.bones.active = owner_active
        if target_arm and (target_active := target_arm.bones.get(mapping.target)):
            target_arm.bones.active = target_active

    def update_select(self, context):
        """Synchronize bone selection."""
        state = get_state()
        if not state or not state.sync_select:
            return
        owner_selection = {m.owner for m in state.mappings if m.selected}
        target_selection = {m.target for m in state.mappings if m.selected}
        owner_arm, target_arm = state.get_owner_armature(), state.get_target_armature()
        if owner_arm:
            for bone in owner_arm.bones:
                bone.select = bone.name in owner_selection
        if target_arm:
            for bone in target_arm.bones:
                bone.select = bone.name in target_selection

    def _apply_mappings(self, context):
        """Apply all valid mappings."""
        state = get_state()
        if not state or not state._needs_constraint_update:
            return
        for m in state.mappings:
            if m.is_valid():
                m.apply()
        state._needs_constraint_update = False

    def _clear_mappings_cache(self):
        """Clear cached constraints."""
        for m in self.mappings:
            m.clear()

    selected_target: bpy.props.PointerProperty(
        type=bpy.types.Object,
        poll=lambda self, obj: obj.type == 'ARMATURE' and obj != bpy.context.scene.kumopult_bac_owner,
        update=update_target
    )
    target: bpy.props.PointerProperty(type=bpy.types.Object)
    owner: bpy.props.PointerProperty(type=bpy.types.Object)
    
    mappings: bpy.props.CollectionProperty(type=BAC_BoneMapping)
    active_mapping: bpy.props.IntProperty(default=-1, update=update_active)
    selected_count: bpy.props.IntProperty(default=0, update=update_select)
    
    editing_type: bpy.props.IntProperty(description="Records the panel type")
    preview: bpy.props.BoolProperty(
        default=True,
        description="Toggle all constraints to preview baked animations",
        update=update_preview
    )
    sync_select: bpy.props.BoolProperty(
        default=False, name="Synchronize Selection", 
        description="Automatically activate corresponding bones when clicking a list item\nAutomatically select corresponding bones when checking a list item"
    )
    calc_offset: bpy.props.BoolProperty(
        default=True, name="Auto Calculate Offset", 
        description="Automatically calculate rotation offset when setting mapping target"
    )
    ortho_offset: bpy.props.BoolProperty(
        default=True, name="Orthogonal", 
        description="Approximate calculated results to multiples of 90°"
    )

    def _get_armature(self, obj):
        """Return armature data for an object."""
        return obj.data if obj and obj.type == 'ARMATURE' else None

    def get_target_armature(self):
        """Return the target armature data."""
        return self._get_armature(self.target)

    def get_owner_armature(self):
        """Return the owner armature data."""
        return self._get_armature(self.owner)
    
    def get_target_pose(self):
        """Return the target pose."""
        return self.target.pose if self.target else None

    def get_owner_pose(self):
        """Return the owner pose."""
        return self.owner.pose if self.owner else None

    def get_active_mapping(self):
        """Return the active mapping."""
        return self.mappings[self.active_mapping] if 0 <= self.active_mapping < len(self.mappings) else None

    def get_mapping_by_target(self, name):
        """Find a mapping by target bone name."""
        if not name:
            return None, -1
        cache_key = f"target_{name}"
        if cache_key in self._mapping_cache:
            return self._mapping_cache[cache_key]
        for i, m in enumerate(self.mappings):
            if m.target == name:
                self._mapping_cache[cache_key] = (m, i)
                return m, i
        return None, -1

    def get_mapping_by_owner(self, name):
        """Find a mapping by owner bone name."""
        if not name:
            return None, -1
        cache_key = f"owner_{name}"
        if cache_key in self._mapping_cache:
            return self._mapping_cache[cache_key]
        for i, m in enumerate(self.mappings):
            if m.owner == name:
                self._mapping_cache[cache_key] = (m, i)
                return m, i
        return None, -1

    def get_selection(self):
        """Get selected mapping indices."""
        if self.selected_count == 0 and 0 <= self.active_mapping < len(self.mappings):
            return [self.active_mapping]
        return [i for i, m in enumerate(self.mappings) if m.selected]

    def add_mapping(self, owner, target, index=-1):
        """Add a new mapping."""
        if index == -1:
            index = self.active_mapping + 1 if self.active_mapping != -1 else 0
        if m := self.get_mapping_by_owner(owner)[0]:
            m.target = target
            self.active_mapping = self.get_mapping_by_owner(owner)[1]
        else:
            m = self.mappings.add()
            m.selected_owner = owner
            m.target = target
            if index < len(self.mappings):
                self.mappings.move(len(self.mappings) - 1, index)
            self.active_mapping = index
        self._needs_constraint_update = True
        return m, index

    def remove_mapping(self):
        """Remove selected mappings."""
        for i in sorted(self.get_selection(), reverse=True):
            self.mappings[i].clear()
            self.mappings.remove(i)
        self.active_mapping = min(self.active_mapping, len(self.mappings) - 1)
        self.selected_count = 0
        self._needs_constraint_update = True
        self._mapping_cache.clear()

# =============================================
# UI List and Operators
# =============================================

class BAC_UL_mappings(bpy.types.UIList):
    def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index, flt_flag):
        s = get_state()
        if not s:
            return
        layout.alert = not item.is_valid()
        layout.active = item.selected or s.selected_count == 0
        row = layout.row(align=True)
        owner_arm, target_arm = s.get_owner_armature(), s.get_target_armature()

        def mapping():
            row.prop(item, 'selected', text='', emboss=False, icon='CHECKBOX_HLT' if item.selected else 'CHECKBOX_DEHLT')
            row.prop_search(item, 'selected_owner', owner_arm, 'bones', text='', translate=False, icon='BONE_DATA')
            row.label(icon='BACK')
            row.prop_search(item, 'target', target_arm, 'bones', text='', translate=False, icon='BONE_DATA')
        
        def rotation():
            row.prop(item, 'has_rotoffs', icon='CON_ROTLIKE', icon_only=True)
            layout.label(text=item.selected_owner, translate=False)
            if item.has_rotoffs:
                layout.prop(item, 'offset', text='')
        
        def location():
            row.prop(item, 'has_loccopy', icon='CON_LOCLIKE', icon_only=True)
            layout.label(text=item.selected_owner, translate=False)
            if item.has_loccopy:
                cp = item.get_cp()
                layout.prop(cp, 'use_x', text='X', toggle=True)
                layout.prop(cp, 'use_y', text='Y', toggle=True)
                layout.prop(cp, 'use_z', text='Z', toggle=True)
        
        def ik():
            row.prop(item, 'has_ik', icon='CON_KINEMATIC', icon_only=True)
            layout.label(text=item.selected_owner, translate=False)
            if item.has_ik:
                layout.prop(item.get_ik(), 'influence')
        
        draw_funcs = {0: mapping, 1: rotation, 2: location, 3: ik}
        draw_funcs[s.editing_type]()

class BAC_MT_SettingMenu(bpy.types.Menu):
    bl_label = "Settings"
    def draw(self, context):
        s = get_state()
        if not s:
            return
        layout = self.layout
        layout.prop(s, 'sync_select')
        layout.separator()
        layout.prop(s, 'calc_offset')
        layout.prop(s, 'ortho_offset')

class BAC_MT_presets(bpy.types.Menu):
    bl_label = "Mapping Presets"
    preset_subdir = "kumopult_bac"
    preset_operator = "script.execute_preset"
    draw = bpy.types.Menu.draw_preset

class AddPresetBACMapping(AddPresetBase, bpy.types.Operator):
    bl_idname = "kumopult_bac.mappings_preset_add"
    bl_label = "Add BAC Mappings Preset"
    bl_description = "Save the current bone mapping list as a preset for later use"
    preset_menu = "BAC_MT_presets"
    preset_defines = ["s = bpy.context.scene.kumopult_bac_owner.data.kumopult_bac"]
    preset_values = ["s.mappings", "s.selected_count"]
    preset_subdir = "kumopult_bac"

class BAC_OT_OpenPresetFolder(bpy.types.Operator):
    bl_idname = 'kumopult_bac.open_preset_folder'
    bl_label = 'Open Preset Folder'
    def execute(self, context):
        os.startfile(bpy.utils.resource_path('USER') + r'\scripts\presets\kumopult_bac')
        return {'FINISHED'}

class BAC_OT_SelectEditType(bpy.types.Operator):
    bl_idname = 'kumopult_bac.select_edit_type'
    bl_label = ''
    bl_description = 'Select edit list type'
    bl_options = {'UNDO'}
    selected_type: bpy.props.IntProperty()

    def execute(self, context):
        if s := get_state():
            s.editing_type = self.selected_type
        return {'FINISHED'}

class BAC_OT_SelectAction(bpy.types.Operator):
    bl_idname = 'kumopult_bac.select_action'
    bl_label = 'List Selection Action'
    bl_description = 'Select All/Deselect/Invert Selection'
    bl_options = {'UNDO'}
    action: bpy.props.StringProperty()

    def execute(self, context):
        s = get_state()
        if not s:
            return {'FINISHED'}
        actions = {
            'ALL': lambda: (setattr(m, 'selected', True) for m in s.mappings),
            'INVERSE': lambda: (setattr(m, 'selected', not m.selected) for m in s.mappings),
            'NONE': lambda: (setattr(m, 'selected', False) for m in s.mappings)
        }
        if self.action in actions:
            for _ in actions[self.action](): pass
            s.selected_count = sum(1 for m in s.mappings if m.selected)
        return {'FINISHED'}

class BAC_OT_ListAction(bpy.types.Operator):
    bl_idname = 'kumopult_bac.list_action'
    bl_label = 'List Basic Operations'
    bl_description = 'Add, Remove, Move Up, Move Down\nIn pose mode, selecting a bone and clicking Add will auto-fill the corresponding bone'
    bl_options = {'UNDO'}
    action: bpy.props.StringProperty()

    def execute(self, context):
        s = get_state()
        if not s:
            return {'FINISHED'}
        owner_arm, target_arm = s.get_owner_armature(), s.get_target_armature()
        actions = {
            'ADD': lambda: s.add_mapping('', ''),
            'ADD_SELECT': lambda: [s.add_mapping(name, '') for name in ([b.name for b in owner_arm.bones if b.select] if owner_arm else [])] or [s.add_mapping('', '')],
            'ADD_ACTIVE': lambda: s.add_mapping(
                owner_arm.bones.active.name if owner_arm and owner_arm.bones.active else '',
                target_arm.bones.active.name if target_arm and target_arm.bones.active else ''
            ),
            'REMOVE': lambda: s.remove_mapping() if s.mappings else None,
            'UP': lambda: self._move_mappings_up(s),
            'DOWN': lambda: self._move_mappings_down(s)
        }
        if self.action in actions:
            actions[self.action]()
        return {'FINISHED'}

    def _move_mappings_up(self, s):
        """Move selected mappings up."""
        if s.selected_count == 0 and 0 < s.active_mapping < len(s.mappings):
            s.mappings.move(s.active_mapping, s.active_mapping - 1)
            s.active_mapping -= 1
        else:
            for i in sorted([i for i in range(1, len(s.mappings)) if s.mappings[i].selected], reverse=True):
                if not s.mappings[i - 1].selected:
                    s.mappings.move(i, i - 1)

    def _move_mappings_down(self, s):
        """Move selected mappings down."""
        if s.selected_count == 0 and 0 <= s.active_mapping < len(s.mappings) - 1:
            s.mappings.move(s.active_mapping, s.active_mapping + 1)
            s.active_mapping += 1
        else:
            for i in sorted([i for i in range(len(s.mappings) - 1) if s.mappings[i].selected]):
                if not s.mappings[i + 1].selected:
                    s.mappings.move(i, i + 1)

class BAC_OT_ChildMapping(bpy.types.Operator):
    bl_idname = 'kumopult_bac.child_mapping'
    bl_label = 'Child Mapping'
    bl_description = 'If the selected mapping’s target and owner bones each have exactly one child, create a new mapping between those children'
    bl_options = {'UNDO'}
    execute_flag: bpy.props.BoolProperty(default=False)
    
    @classmethod
    def poll(cls, context):
        s = get_state()
        return s and all(s.mappings[i].is_valid() for i in s.get_selection())
    
    def execute(self, context):
        s = get_state()
        if not s:
            return {'FINISHED'}
        self.execute_flag = False
        owner_arm, target_arm = s.get_owner_armature(), s.get_target_armature()
        if not owner_arm or not target_arm:
            return {'FINISHED'}
        
        for i in sorted(s.get_selection()):
            m = s.mappings[i]
            if m.selected:
                m.selected = False
            target_children = target_arm.bones[m.target].children
            owner_children = owner_arm.bones[m.owner].children
            if len(target_children) == len(owner_children) == 1:
                new_mapping = s.add_mapping(owner_children[0].name, target_children[0].name, i + 1)[0]
                new_mapping.selected = True
                self.execute_flag = True
            elif owner_children:
                for j, child in enumerate(owner_children):
                    new_mapping = s.add_mapping(child.name, '', i + j + 1)[0]
                    new_mapping.selected = True
                    self.execute_flag = True
        
        if not self.execute_flag:
            self.report({"ERROR"}, "No valid child mappings found in selected mappings")
        return {'FINISHED'}

class BAC_OT_NameMapping(bpy.types.Operator):
    bl_idname = 'kumopult_bac.name_mapping'
    bl_label = 'Name Mapping'
    bl_description = 'Automatically find the closest matching target bone based on name similarity'
    bl_options = {'UNDO'}
    
    @classmethod
    def poll(cls, context):
        s = get_state()
        return s and all(s.mappings[i].get_owner() is not None for i in s.get_selection())
    
    def get_similar_bone(self, owner_name, target_bones):
        """Find the most similar bone name using simple string matching.
        Note: Can be extended with difflib or Levenshtein distance for more complex matching.
        """
        owner_lower = owner_name.lower().replace('_', '')
        for target in target_bones:
            target_lower = target.name.lower().replace('_', '')
            if owner_lower == target_lower or owner_lower in target_lower or target_lower in owner_lower:
                return target.name
        return ''

    def execute(self, context):
        s = get_state()
        if not s:
            return {'FINISHED'}
        target_bones = s.get_target_armature().bones
        for i in s.get_selection():
            if m := s.mappings[i]:
                m.target = self.get_similar_bone(m.owner, target_bones)
        return {'FINISHED'}

class BAC_OT_MirrorMapping(bpy.types.Operator):
    bl_idname = 'kumopult_bac.mirror_mapping'
    bl_label = 'Mirror Mapping'
    bl_description = 'If the selected mapping’s target and owner bones have symmetrical bones, create a new mapping between those symmetrical bones'
    bl_options = {'UNDO'}
    execute_flag: bpy.props.BoolProperty(default=False)
    
    @classmethod
    def poll(cls, context):
        s = get_state()
        return s and all(s.mappings[i].is_valid() for i in s.get_selection())
    
    def execute(self, context):
        s = get_state()
        if not s:
            return {'FINISHED'}
        self.execute_flag = False
        owner_pose, target_pose = s.get_owner_pose(), s.get_target_pose()
        if not owner_pose or not target_pose:
            return {'FINISHED'}
        
        for i in sorted(s.get_selection()):
            m = s.mappings[i]
            if m.selected:
                m.selected = False
            owner_mirror = owner_pose.bones.get(bpy.utils.flip_name(m.owner))
            target_mirror = target_pose.bones.get(bpy.utils.flip_name(m.target))
            if owner_mirror and target_mirror:
                new_mapping = s.add_mapping(owner_mirror.name, target_mirror.name, i + 1)[0]
                new_mapping.selected = True
                self.execute_flag = True
        
        if not self.execute_flag:
            self.report({"ERROR"}, "No mirrorable mappings found in selected mappings")
        return {'FINISHED'}

class BAC_OT_Bake(bpy.types.Operator):
    bl_idname = 'kumopult_bac.bake'
    bl_label = 'Bake Animation'
    bl_description = 'Bake constraint effects into a new action based on the source armature’s action frame range'
    bl_options = {'UNDO'}
    
    def execute(self, context):
        s = get_state()
        if not s or not s.target or not s.target.animation_data or not s.target.animation_data.action:
            alert_error('No action on source armature!', 'An action is required to determine the baking frame range')
            return {'FINISHED'}
        
        # Backup non-BAC constraints
        non_bac_con = {}
        owner_pose = s.get_owner_pose()
        if owner_pose:
            non_bac_con = {
                pb.name: [(con, con.enabled) for con in pb.constraints if not con.name.startswith('BAC')]
                for pb in owner_pose.bones if any(not con.name.startswith('BAC') for con in pb.constraints)
            }
        
        # Perform baking
        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')
        bpy.context.view_layer.objects.active = s.owner
        s.owner.select_set(True)
        
        s.preview = True
        action = s.target.animation_data.action
        bpy.ops.nla.bake(
            frame_start=int(action.frame_range[0]),
            frame_end=int(action.frame_range[1]),
            only_selected=False,
            visual_keying=True,
            bake_types={'POSE'}
        )
        s.preview = False
        
        # Restore non-BAC constraints
        if owner_pose:
            for bone_name, constraints in non_bac_con.items():
                if pb := owner_pose.bones.get(bone_name):
                    for con, enabled in constraints:
                        con.enabled = enabled
        
        # Rename action
        if s.owner.animation_data and s.owner.animation_data.action:
            s.owner.animation_data.action.name = f"{s.target.name}_baked"
            s.owner.animation_data.action.use_fake_user = True
        
        return {'FINISHED'}

# =============================================
# Main Panel
# =============================================

class BAC_PT_Panel(bpy.types.Panel):
    bl_space_type = "VIEW_3D"
    bl_region_type = "UI"
    bl_category = "BoneAnimCopy"
    bl_label = "Bone Animation Copy"
    
    def draw(self, context):
        layout = self.layout
        split = layout.row().split(factor=0.2)
        left, right = split.column(), split.column()
        
        left.label(text="Owner Armature:")
        left.label(text="Target Armature:")
        owner = context.scene.kumopult_bac_owner
        right.prop(context.scene, 'kumopult_bac_owner', text='', icon='ARMATURE_DATA', translate=False)
        
        if owner and owner.type == 'ARMATURE':
            s = get_state()
            right.prop(s, 'selected_target', text='', icon='ARMATURE_DATA', translate=False)
            
            if not s.target:
                layout.label(text="Select another armature as the target to continue", icon='INFO')
            else:
                row = layout.row()
                self.draw_mapping_panel(row, s)
                row = layout.row()
                row.prop(s, 'preview', text='Preview Constraints', icon='HIDE_OFF' if s.preview else 'HIDE_ON')
                row.operator('kumopult_bac.bake', text='Bake Animation', icon='NLA')
        else:
            right.label(text="No owner armature selected", icon='ERROR')
    
    def draw_mapping_panel(self, layout, s):
        row = layout.row()
        left = row.column_flow(columns=1, align=True)
        
        # Selection/edit type buttons
        box = left.box().row()
        if s.editing_type == 0:
            box_left = box.row(align=True)
            box_left.operator('kumopult_bac.select_action', text='', emboss=False, 
                            icon='CHECKBOX_HLT' if s.selected_count == len(s.mappings) else 'CHECKBOX_DEHLT').action = 'NONE' if s.selected_count == len(s.mappings) else 'ALL'
            if s.selected_count != 0:
                box_left.operator('kumopult_bac.select_action', text='', emboss=False, icon='UV_SYNC_SELECT').action = 'INVERSE'
        
        box_right = box.row(align=False)
        box_right.alignment = 'RIGHT'
        for i, (text, icon) in enumerate([('Mapping', 'PRESET'), ('Rotation', 'CON_ROTLIKE'), 
                                        ('Location', 'CON_LOCLIKE'), ('IK', 'CON_KINEMATIC')]):
            box_right.operator('kumopult_bac.select_edit_type', text='' if s.editing_type != i else text, 
                            icon=icon, emboss=True, depress=s.editing_type == i).selected_type = i
        
        # Mapping list
        left.template_list('BAC_UL_mappings', '', s, 'mappings', s, 'active_mapping', rows=7)
        
        # Preset menu
        box = left.box().row(align=True)
        box.menu('BAC_MT_presets', text='Presets', translate=False, icon='PRESET')
        box.operator('kumopult_bac.mappings_preset_add', text="", icon='ADD')
        box.operator('kumopult_bac.mappings_preset_add', text="", icon='REMOVE').remove_active = True
        box.separator()
        box.operator('kumopult_bac.open_preset_folder', text="", icon='FILE_FOLDER')
        
        right = row.column(align=True)
        right.separator()
        right.menu('BAC_MT_SettingMenu', text='', icon='DOWNARROW_HLT')
        right.separator()
        
        # List operation buttons
        right.operator('kumopult_bac.list_action', icon='ADD' if s.owner.mode != 'POSE' else 'PRESET_NEW' if s.target.mode != 'POSE' else 'PLUS', 
                     text='').action = 'ADD' if s.owner.mode != 'POSE' else 'ADD_SELECT' if s.target.mode != 'POSE' else 'ADD_ACTIVE'
        right.operator('kumopult_bac.list_action', icon='REMOVE', text='').action = 'REMOVE'
        right.operator('kumopult_bac.list_action', icon='TRIA_UP', text='').action = 'UP'
        right.operator('kumopult_bac.list_action', icon='TRIA_DOWN', text='').action = 'DOWN'
        right.separator()
        right.operator('kumopult_bac.child_mapping', icon='CON_CHILDOF', text='')
        right.operator('kumopult_bac.name_mapping', icon='CON_TRANSFORM_CACHE', text='')
        right.operator('kumopult_bac.mirror_mapping', icon='MOD_MIRROR', text='')

# =============================================
# Registration
# =============================================

classes = (
    BAC_BoneMapping,
    BAC_State,
    BAC_UL_mappings,
    BAC_MT_SettingMenu,
    BAC_MT_presets,
    AddPresetBACMapping,
    BAC_OT_OpenPresetFolder,
    BAC_OT_SelectEditType,
    BAC_OT_SelectAction,
    BAC_OT_ListAction,
    BAC_OT_ChildMapping,
    BAC_OT_NameMapping,
    BAC_OT_MirrorMapping,
    BAC_OT_Bake,
    BAC_PT_Panel
)

def register():
    """Register all classes for the add-on."""
    for cls in classes:
        bpy.utils.register_class(cls)
    
    bpy.types.Scene.kumopult_bac_owner = bpy.props.PointerProperty(
        type=bpy.types.Object, 
        poll=lambda self, obj: obj.type == 'ARMATURE'
    )
    bpy.types.Armature.kumopult_bac = bpy.props.PointerProperty(type=BAC_State)

def unregister():
    """Unregister all classes for the add-on."""
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    
    del bpy.types.Scene.kumopult_bac_owner
    del bpy.types.Armature.kumopult_bac

if __name__ == "__main__":
    register()